\chapter{Work/Design}

In this chapter I will describe the work I have done in order to implement model-based testing into the MCP. The workload that is contained in the implementation and description herein includes a model-building module, which is able to simulate given examples of maritime protocols. Furthermore, I will update the structure of the xml specification files, based on which I will introduce a parser/interpreter implementation, thus allowing me to automatically generate maritime models, equivalent to the one that I have created manually.

\section{Updated Data}

As discussed in Section \ref{sec:Data}, in order to create uniform models, upon which to execute tests, the structure of the xml-specification files needs to be altered in a manner that adds uniformity to the xml-specification files. This rules out the use of natural language, for reliable model-generation.

One way to implement these changes is make the user able to assign variables, based on a fixed collection of available options. I will now present three fields, which are designed to be used in order to maximize uniformity in model generation as well as give maximum flexibility in future model design.
\begin{description}
	\item[Entity]\ \\
	An entity is the most basic component of the models, without which, the models be devoid of all data. These describe the physical real-world objects, which the model is to simulate, and these are also the subjects of all transactions, which occurs throughout execution of a model. At the moment, three entities exist, however implementation of support for additional models is possible.
	Multiple instances of each entity is allowed in a model.
	\begin{description}
		\item[Ship]\ \\
			If comparing the MCP to the App Store or Google Play, a ship would undertake the role of the user. The user can be the one utilizing the maritime service.
		\item[Service]\ \\
			The Service entity represents the maritime service, which is being modeled. If multiple instances of a service entity occurs, this will correspond to cross app interaction, using the same comparison as above.
		\item[Company]\ \\
			Company entities serve as nodes, which hold data or similar goods, which can be desired by ship entities for a variety of reasons. If multiple company entities exist at one time, they will not necessarily need a service entity to connect them. 
	\end{description}
	\item[Relation]\ \\
		A relation symbolizes a bond between two entities. In the case of Figure \ref{fig:modelExProtocol}, relations can be seen between 'Ship' and 'Service' as well as 'Service' and 'Company'.

		A ship entity can share a relation with service entities, as they would have no way of communicating with company or ship entities without any prior software. In the case that a ship communicates with another ship, it will need an intermediate service entity to communicate through.

		A service entity needs to be able to share a relation with all other entities in order to act as an intermedium between ship entities and company entities, while also being able to interact with other service entities.

		A company entity can share a relation with a service entity as well as other company entities. Two company entities do not necessarily need service entities in order to be able to share information similarly to the real world, where companies use different communication channels, when communicating with companies and citizens.
	\item[Dependency]\ \\
		A dependency is, as the name suggests, a dependency from one entity to another, and so the first argument of a dependency must be a relation, that describes which two entities are in question, as well as which entity depends on the other. The second argument that a dependency must receive is a constraint function, that describes what the entities require from each other. If two entities co-depend on each other a relation must be made from the first to the second, as well as from the second to the first. As only the constraint function limits what the dependency entails, an entity \tit{can} depend on itself.
	\item[Information]\ \\
		All entities are able to store information, which is able to be requested, transfered, and deleted. This is meant to represent various data, be it maps, keys, messages or other.
\end{description}

Figure \ref{fig:entities} describe which options are excluded at selections of entities, relations, and dependencies. As can be seen, Figure \ref{fig:entities} coincides with \ref{fig:sSpecUpd}, and therefor the description given in this section describe both figures. 

\begin{figure}
	\centering
	\begin{tikzpicture}[->,>=stealth', node distance=5 cm]
		\node[]	(A)	[]	
			{\begin{tabular}{|l|}\hline{1}
				Entity         \\ \hline{2.5}
				Ship            \\ \hline{1}
				Service          \\ \hline{1}
				Company	          \\ \hline{1}
			\end{tabular}};
		\node[]	(B)	[above right of=A]
			{\begin{tabular}{|l|}\hline{1}
				Relation       \\ \hline{2.5}
				Ship            \\ \hline{1}
				Service          \\ \hline{1}
			\end{tabular}};
		\node[]	(C)	[right of=A]
			{\begin{tabular}{|l|}\hline{1}
				Relation       \\ \hline{2.5}
				Ship            \\ \hline{1}
				Service          \\ \hline{1}
				Company           \\ \hline{1}
			\end{tabular}};
		\node[]	(D)	[below right of=A]
			{\begin{tabular}{|l|}\hline{1}
				Relation       \\ \hline{2.5}
				Service         \\ \hline{1}
				Company          \\ \hline{1}
			\end{tabular}};
		\node[]	(E)	[right of=B]
			{\begin{tabular}{|l|}\hline{1}
				Dependency     \\ \hline{2.5}
				Service          \\ \hline{1}
			\end{tabular}};
		\node[]	(F)	[right of=C]
			{\begin{tabular}{|l|}\hline{1}
				Dependency     \\ \hline{2.5}
				Ship            \\ \hline{1}
				Service          \\ \hline{1}
				Company           \\ \hline{1}
			\end{tabular}};
		\node[]	(G)	[right of=D]
			{\begin{tabular}{|l|}\hline{1}
				Dependency     \\ \hline{2.5}
				Service         \\ \hline{1}
				Company          \\ \hline{1}
			\end{tabular}};
		\path	(A)	edge	[out=10]	node	{}	(B)
					edge	[out=345]	node	{}	(C)
					edge	[out=325]	node	{}	(D)
				(B)	edge	[out=30]	node	{}	(E)
				(C)	edge	[out=30]	node	{}	(F)
				(D)	edge	[out=30]	node	{}	(G);
	\end{tikzpicture}
	\caption{Available relations and dependencies for ships, services, and companies}
	\label{fig:entities}
\end{figure}


\section{Updated Parser Grammars}

The fields described in Section \ref{sec:Updated Data} furthermore need to be translated into parsable xml, and an example of this is given in Listing \ref{fig:sSpecUpd}. This parser grammar serves as an updated version of the parser grammar, described in Listing \ref{fig:sSpecFull}, however shaved for information\footnote{aSpec, authorInfo, authorInfos, contactInfo, dataExchangePattern, definitionAsXSD, description, isSpatialExclusive, keywords, oSpec, operation, operations, parameterType, parameterTypes, ptSpec, rSpec, requirement, requirements, returnValueType, serviceDataModel, serviceInterface, serviceInterfaces, siSpec, spec, specifications, status, text, typeReference, version}, that is irrelevant to the model-generating process. While this information can of course be included in the xml-specification file, it will be deemed irrelevant after parsing, and thus not included further in the model-generating process. The parser grammar presented in Listing \ref{fig:sSpecUpd} is designed to form a clear and unambiguous collection of entities, along with a similarly unambiguous description of relations, exchange-patterns, and security precautions. The parser grammar abides by the rules, presented in Section \ref{sec:Updated Data} and Figure \ref{fig:entities}.

\subsection{Updated Service Specification Grammar}

\begin{figure}
	\centering
	\begin{lstlisting}[keywordstyle={}]
ServiceSpecificationSchema ::= specifications

specifications ::= entities specifications
    | $\e$
     
entities ::= ent entities
    | $\e$

ent ::= type
    | name
    | relations
    | dependencies
    | information
    | requests

type ::= atom

name ::= String

relations ::= relation Relations
    | $\e$

relation ::= ent

dependencies ::= dependency dependencies
    | $\e$

dependency ::= relation
    | constraint

constraint ::= function

information ::= info information
    | $\e$

info ::= variant

requests ::= request requests
    | $\e$

request ::= relation
    | info
    | answers

answers ::= answer answers
    | $\e$

answer ::= variant
	\end{lstlisting}
	\caption{Updated parser grammar of Service Specification Schema}
	\label{fig:sSpecUpd}
\end{figure}
\subsection{Updated General Grammar}
The updated xml-specification files will be limiting the flexibility of the models in some aspects, as not all maritime services would follow the structure given in Listing \ref{fig:sSpecUpd}, however the example given is the earliest version of the domain-specific language. Following complex structures of various maritime services, the domain-specific language of the specification files can scale in complexity with the requirements set up by the maritime services.

Listing \ref{fig:sSpecUpdRed} describes a reduced form of Listing \ref{fig:sSpecUpd}. It can be seen that Listing \ref{fig:sSpecUpdRed} is identical to Listing \ref{fig:sSpecRed}, which proves that, after implementation of the model-generating process, there is no direct, urgent need to improve or change the parser.

\begin{figure}
	\centering
	\begin{lstlisting}[keywordstyle={}]
ServiceSpecificationSchema ::= specifications

specifications ::= spec specifications
    | $\e$
     
spec ::= specifications
    | spec
    | $\e$

spec ::= string
	\end{lstlisting}
	\caption{Reduced parser grammar of the updated Service Specification Schema}
	\label{fig:sSpecUpdRed}
\end{figure}

\section{Implementation in the MCP}
As described in Chapter \ref{chp:Analysis}, the choice between the two model creation plays a vital role in the utilization

\section{Technical Implementation}
The project is implemented in Erlang, and contained in the files \ttt{aux.erl}, \ttt{interpr eter.erl}, \ttt{mmods.erl}, (maritime models) \ttt{parser.erl}, \ttt{tests.erl}, and \ttt{main.erl}, along with the \ttt{xml}-folder, containing models and simulations in xml-format.

\subsection{The mmods module}
The core of the project is contained in the \ttt{mmods.erl} file, which contains the functionality, that creates the finite state machine models. This module creates processes which includes the following fields:
\begin{description}
	\item[\ttt{Type}]\ \\
		This field is described by a single atom, which is only able to take the forms of either \ttt{ship}, \ttt{service}, or \ttt{company}. This is used to check the legality of relations, when adding these.
	\item[\ttt{Relations}]\ \\
		The \ttt{Relations} field is described by a tuple list, containing a set of relations, as well of its corresponding dependencies, if any exist. Dependencies are represented by a list of functions, evaluating to \ttt{true} or \ttt{false}.
	\item[\ttt{Self}]\ \\
		The \ttt{Self} field is made up of the corresponding process id.
	\item[\ttt{Info}]\ \\
		The \ttt{Info} field consists of all data representation, which can take any form.
\end{description}
The functions \ttt{start/1}, \ttt{add\_relation/2}, \ttt{add\_dependency/3}, \ttt{add\_info/2}, \ttt{remove\_info/2}, \ttt{transfer\_info/3}, and \ttt{request\_info/4}, all add their corresponding self-descriptive functionality through the use of the \ttt{gen\_statem} (generic state machine) module. The getter-functions \ttt{get\_state/1}, \ttt{get\_type/1}, \ttt{get\_relations/1}, and \ttt{get\_info/1}, perform the simple task of retrieving relevant informations for the provided process id.
\subsection{The parser and interpreter modules}

\begin{description}
	\item[The parser module]\ \\
		The parser module utilizes the \ttt{xmerl} library of functions to standardly perform well formed parsing of xml files. Additionally, the \ttt{xml\_parser/1}-function uses the accumulator function \ttt{accFun}, which accumulates all field values, that are \tit{not} purely whitespace and/or newline. Along with the hook function \ttt{hookFun} that binds the parser output to a tuple, consisting of an atom, describing the parsed node, along with its contents. Furthermore, \ttt{hookFun} dictates that pure text contents are just that - not a list, consisting of one string, which it would be otherwise. The parser module is created, following both the xmerl reference manual\cite{xmerl} and an example posted online\cite{xmerlEx}, and the parser grammar, described in Figures \ref{fig:sSpecUpd} and \ref{fig:sSpecUpdRed}.
	\item[The interpreter module]\ \\
		The interpreter module exports the single function \ttt{interp/1}. This function takes in an Erlang term of the form, described above \footnote{A tuple} and recursively loops the content value in order to exhaust the information, stored in the term. The \ttt{interp/1} function adds builds maritime models in the order that is adding entities, info, relations, dependencies, and lastly performing information requests. Each adder function dynamically searches its corresponding keyword rather than retrieving by index in the xml term, which allows for variation in the the structure of the xml along with interchangeability in the order of the adder functions. Two constraints do exist in the order of which components are added to the model, the first being that entity addition must always come first, as no data can be bound to nonexistent entities. The other constraint is that dependencies must be added \tit{after} relations, as a dependency can only be placed on top of an existing relation. Finally the interpreter shows the states of all entities, as is after addition of all data. Models \ttt{can} be interacted with post-automatic creation.
\end{description}
\subsection{Executing Instructions}
In an Erlang-shell all files can be compiled with \ttt{c(file)}, where after manual model generation can be run from the \ttt{mmods.erl} file \footnote{See \ttt{tests.erl} for examples}.
For automatic model generation, the \ttt{main.erl} file gathers the functionality of the parser- and interpreter-modules, which in turn draws upon the mmods-module. From here, the user has the possibilities of parsing an \ttt{xml}-file, interpreting an Erlang term, though the uses of \ttt{main:parse/1}, \ttt{main:interpret/1} or using the combined function \ttt{main:parse\_and\_interpret/1} which fully converts an \ttt{xml}-file to a working maritime model.

Using a model post-creation both possible though the uses of manual and automatic model-creating. 
\section{Testing}
Testing of the implementation has been divided into two parts, one of which is detailed here, the other in Chapter \ref{chp:Results}. All testing of the mmods module has been contained in the \ttt{tests.erl} file, which includes multiple tests for each API function, exported from the mmods module. After compilation, all tests can be run in an Erlang shell, either as the normal zero-input functions they are, or as the \ttt{main/0} function, which encapsulates all created test cases. All tests are created to return the atom \ttt{true} if they succeed, or the corresponding error message, if they do not.

